\section{Backend testing}
\label{section:backend-testing}
Let me start off with elaborating the testing procedure of the backend.
First, I needed testing data for the test cases themselves.
For this use case, Laravel provides the built-in factory and seeder classes already mentioned partly in Chapter \ref{chapter:backend}.

The factory classes provide a method to create mocked instances of model classes.
The mocked values can either be hard coded test values or generated by the FakerPHP package.
The aforementioned package boasts a wide variety of methods to create organic feeling testing data.
Apart from simple data types, such as numbers and text, complex data for everyday use cases can be generated too.
This includes, but is not limited to various file types (images, HTML), emails, addresses, payment information, etc.
I created a custom enum for testing the editor content with two cases, the first representing the encoded value, and the second containing the raw value.
As such, I implemented factory classes for all of my application's models with fake data.

Seeders, on the other hand, fill the database with data, in this case conveniently created by factories.
Inside seeders, while generating fake data, relationships can be handled and generated accordingly, too.
I created seeder classes for all models, and a test seeder, which calls each of these to prepare the database for testing.

Laravel also incorporates a way to mock certain aspects of the application, such as event listeners and services.
I used this feature to mock the deployment service and sanitizer service during tests.
I also faked the HTTP client to intercept outgoing request to the proxy application and provide mocked responses.

Next, the testing environment has to be set up.
Sail provides a separate database connection for testing out of the box, to avoid touching the main database.
I then configured tests to refresh this test database between each test run and auto seed it with the test seeder's data.
This ensures that the results of previous test runs have no effect on one another, and they are isolated properly.

After this, the test cases themselves were written using the PHPUnit testing framework.
It is fully supported by Laravel out of the box and has an object-oriented approach to writing tests.
Tests are classes, where each test method has to be prefixed with the \texttt{test} word to be picked up by the framework during execution.
I wrote unit tests for the two custom services, to ensure they handle external communication and edge cases correctly.
I also tested the form request classes' validation logic for incoming data.
Lastly, I wrote feature tests for all the controllers' logic, testing CRUD functionality.

These all accounted to a 64\% line coverage, which covers 60\% of functions and methods.
I excluded from the coverage report the Filament and Fortify related functions.
The authors of the packages thoroughly test them, and since I used them without modifying the inner workings, they should function as intended.
Thus, the implemented tests ensure the backend works according to the requirements.
Figure \ref{fig:backend-coverage} shows the generated coverage report.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/backend-coverage.png}
  \caption{Backend test coverage report}
  \label{fig:backend-coverage}
\end{figure}