\chapter{Architecture}

The goal of the thesis is to develop a template-driven website generator SaaS platform that allows users to create, customize, and publish single-page websites.
Special attention must be paid to scalability, security, and user experience (UX).
A platform that can achieve this task from one end (the user) to the other (deployment) is inherently complex and requires the cooperation and integration of many technologies.
%TODO: talk a little about how I went about solving this problem how this architecture came to be.

To begin with, I will present the overarching high-level architecture of the complete system, introduce each component, then explain the ways they integrate and interact in detail. The architecture itself can be viewed on Figure \ref{fig:architecture}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/architecture.png}
  \caption{System level architecture}
  \label{fig:architecture}
\end{figure}

The system I designed has two main components a Docker host and a Kubernetes cluster.
The Docker host contains the three main applications of the SaaS, each running inside containers and having their own Docker Compose configuration.

I built the frontend primarily using React with the Vite build and bundling tool. It communicates with the backend through a REST API.

The backend relies mainly on Laravel, but also uses MySQL for the database, Mailpit which is a mailing testing tool that acts as an SMTP server and MinIO, an S3 compatible object store.
The backend serves the admin panel using FilamentPHP for the implementation, while Scribe is used to generate the backends API documentation using the Scalar API documentation platform. The backend communicates with both the frontend and the proxy application also through REST.

The Fastify NodeJS web framework provides the basis for the proxy application and the Kubernetes JavaScript library to connect to the running cluster.
It also serves its own OpenAPI specification using the native Fastify OpenAPI plugin.
For the reason of this functionality having its own separate application refer to section \ref{sec:proxy}.

The proxy connects programmatically to the Kubernetes cluster to deploy the created websites using its official JS client library.
The websites are all deployed to a given namespace ('default' namespace if not changed) using a Kubernetes Deployment.
The Deployments have the common style CSS (Cascading Style Sheets) attached as a volume through a ConfigMap.
Furthermore, each Deployment by default has a 10 revision limit, default resource limits set, and a one replica requirement.
In production these values could obviously be reconfigured and scaled up.
Finally, the application also creates a Service for each website as well as an HTTP Route to connect to the Traefik API Gateway of the cluster for routing.

A user thus is able to create and design their website on the frontend which is then saved to the backend and through the proxy app deployed to the running Kubernetes cluster. Outside users can then visit the deployed website through the Traefik API Gateway acting as a reverse proxy.
