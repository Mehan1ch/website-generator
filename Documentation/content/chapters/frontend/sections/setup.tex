\section{Setup and overview}
\label{section:frontend-setup}
I implemented the frontend using React first and foremost.
The most important packages I used are TanStack Router for client side routing, TanStack query for robust data fetching and caching, and CraftJS for the editor capabilities.

As the first step, the React app has to be installed.
I scaffolded the application using the Vite bundling tool's CLI and chose a TypeScript based application.
Then I set TypeScript to use strict type checking to disallow \texttt{any} types, and also installed TailwindCSS and its Vite plugin as I used the ShadCN UI components.
ShadCN distributes its components and blocks in an open code manner through the npx CLI, which means that instead of installing a npm package, the source code of the block gets copied into the application.
This has the advantage that the components can be completely customized if needed, and the downside that the repository size grows considerably.

I also used predesigned UI blocks form ShadCN.IO \cite{shadcn.io_2025}.
While I was building the application all components from this site were open-sourced and free, however as of writing this documentation they introduced many new blocks that got locked behind a subscription. Previously free blocks remained as such, but require a free account now. This change doesn't affect the application as the source code got inserted into the project directly so further use and modification is possible.

Next I used Docker's init command to scaffold a Dockerfile and docker-compose.yaml for containerization, to which I only made minor changes, mostly regarding setting up environment variables.
I also configured ESLint, which is a static code analyser, to ensure better code quality.

Since unlike Laravel, React is unopinionated about the structure of the application, let me talk about how I architected the frontend's folder structure.
I was partly inspired by the Bulletproof React repository \cite{alan2207/bulletproof-react}, however I made a few changes to better fit my needs.
The high level overview of the layout can be seen on Figure \ref{fig:react-structure}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/frontend-struct.png}
  \caption{React application structure}
  \label{fig:react-structure}
\end{figure}

The \texttt{main.tsx} is the setup file for the frontend application, about which I will go into detail shortly.
The \texttt{routeTree.gen.ts} contains the routing tree that TanStack router generates.
For more information about this refer to Subsection \ref{subsection:tanstack-router}.
The \texttt{components} folder contains the UI elements added by the ShadCN library and other component blocks I created using them that are global to the application.
The \texttt{context} includes the globally defined application contexts, that I will talk about in Section \ref{section:api-context}.
Inside \texttt{hooks} live the custom React hooks that I defined.
\texttt{Lib} collects utility functions, global constants and the generated API client, which I will elaborate in Section \ref{section:api-context}.
The \texttt{providers} folder houses the context providers that the aforementioned context objects return.
\texttt{Routes} encompass not only the route hierarchy but using the router's \texttt{-} notation it also colocates any route specific components and logic.
The \texttt{testing} folder accommodates all test related files.
Refer to Section \ref{section:testing-frontend} for a thorough explanation.
Finally, \texttt{types} include all TypeScript types that are either generated by the API client or Zod schemas.

Zod is a library used for schema validation primarily focusing on TypeScript.
I used it in conjunction with React Hook Form, a hook based form library for React, to generate form schemas and provide client side validation.
I also validated search parameters using it in a few routes. A great feature of Zod is that TypeScript types can be inferred from form schemas for further use.

Now let me talk about setting up the application in the \texttt{main.tsx} file.
Some details will be expanded upon later but are understandable at this point as well.

First a router instance has to be constructed, to which the route tree needs to be provided. Additionally, the router context has to be configured with initial values.
This has to include everything that routes need to have access to before even rendering their component.
In my case this contained TanStack query's query client, which is constructed here, the auth context, and a default callback that returns the given routes title.
The latter will be overridden in each route and will be used for breadcrumb generation.
The auth context is undefined at this point and will be updated later.
Here I also set up a default view transition that provides a smoother animation between route switching and scroll restoration.
Moreover, I configured the loader stale time to 0 (never stale) as the query client will handle that instead of the router (both share this concept).
Finally, I changed the default preload method to 'intent', which has the effect of launching loader preloads after 50 milliseconds when a user hovers on the link of the destination route.

Next a component I called \texttt{InnerApp} has to be created.
This component's only purpose is to have access to the useAuth hook and return the router provider with the router instance and a now existing valid authentication context.
The router provider will take care of rendering child routes.

Moving on, I created an \texttt{App} component which wraps the previous \texttt{InnerApp} with the auth provider, the theme provider, and query client provider.
The query client provider has access to the same query client as the router.
Also, I included the \texttt{Toaster} component from the Sonner package created by Emil Kowalski alongside the \texttt{InnerApp}.
This package an easy-to-use and opinionated way of making toast notifications.
I primarily use it to provide feedback to the user from background tasks such as API calls.

Last but not least the \texttt{App} itself is surrounded with React's strict mode component that enables development only extra behaviours with the aim of finding common bugs.
In production, it has no effect and is turned off.
At the end of all this, the component chain gets rendered by the root React DOM object, which finishes the setup process, as the \texttt{index.html} by default includes the \texttt{main.tsx} script.

One last thing I want to talk about here is the root route.
It must be named as \texttt{\_\_root.tsx} and is the root of the route tree. Here the library's Outlet component has to be returned which will take care of rendering all child routes.
Additionally, I implemented application wide, loading, not found and error boundary components to provide a better UX for these scenarios.

For example Figure \ref{fig:not-found} the not found component that renders when a user navigates to a non-existent route.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/not-found.png}
  \caption{Not found component for missing routes}
  \label{fig:not-found}
\end{figure}