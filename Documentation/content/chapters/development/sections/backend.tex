\section{Backend}
\subsection{Setup}
I implemented the backend primarily using the Laravel PHP web framework as stated beforehand.
As the first step the application has to be installed and set up.
This can be done with Laravel's own installer, where many application templates can be selected.
A React template is available, however that uses Inertia.JS by default which is a package that enables the frontend to be server side routed.
I wished to opt out of this and develop a traditional API based SPA, so I decided to use the minimal setup.
So Laravel will serve as an API backend and the view layer of the MVC architecture will be entirely handled by the frontend.

After installation, I decided to install the Laravel Sail package which provides a preconfigured development Docker Compose setup, and also provides options to install additional components into our environment.
The extra containers in our case will be the MySQL database, the Mailpit SMTP test server and the MinIO S3 compatible object storage.
However, the Laravel creators published Sail as a package which by default would need a local PHP and Composer (PHP's package manager) installation.
This would kind of defeat its purpose.
Luckily this can be avoided by using a temporary PHP container to quickly install initial dependencies and then use the Sail application for further required packages.

Afterwards the provided \texttt{.env.example} file needs to be copied to \texttt{.env} and the appropriate environment variables need to be set, including the mail server, database and object storage connections.
Finally, the application key must be initialized using the Artisan CLI and the default database migrations have to be run.

\subsection{Eloquent ORM}

Let me start building up the backend's feature set from the bottom, starting with the parts of the Eloquent ORM.
The database schema of the backend including the most important tables can be seen on Figure \ref{fig:database}.

Laravel has some other default tables, related to built-in features such as jobs and caching that I omitted from the diagram for better clarity as they will be unused in the application.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/database.png}
  \caption{Database schema}
  \label{fig:database}
\end{figure}

The users table is auto generated, the only change I made is regarding the ID (Identifier) field.
In all tables and models I opted to switch from the default integer ID to UUIDv7 (Universally Unique Identifiers version 7) which are time-based sortable universally unique identifiers composed of 32 hexadecimal digits.
The application uses the simplest form of tenancy where each user is a tenant as that is sufficient for the current requirements.

The Spatie Laravel Permission package adds the role related tables, which I will talk about in more detail in the authorization Subsection \ref{subsection:authorization}.

On the other hand the Spatie Media Library provides the media table which will be used to store profile pictures and the HTML files of the static pages.
The application uses the password reset tokens and sessions table for authentication related features.
The Sites table store the websites of the users. Each site must have a unique subdomain that will be assigned to it upon creation and which cannot be changed later.

Also, worth mentioning that each site also has a state that can be either draft or published, to track changes and whether they are visible to the end users.
This is implemented using the Spatie Model States library which adds an easy to configure state machine pattern support with helper functions such as checking viable transitions.
It uses an abstract state (PublishingState) class with actual states being the concrete implementations (Published, Draft).
Allowed transitions and transition handlers are also easy to configure and customize.

A site can also have pages which need a corresponding URL segment (e.g., \texttt{/about}) for routing.
The database stores the pages content in a zlib compressed and base64 encoded format for better transfer and storage efficiency, but can be cast to the uncompressed version if needed.
The structure of the content will be further specified in Section \ref{section:frontend}.
Last but not least the schemas table is a mix of the previous two, having both a content identical to that of the pages table and the same published and draft state as sites.
Schemas allow administrators to create and publish page schemas that users can base their own pages off of.

The models paired with the tables contain most of the business logic that is independent of routes (heavy models).
This includes defining all relationships and their inverses, like in the case of sites and pages a hasMany, and it's inverse belongsTo functions, defining fillable fields that can be assigned from requests, and any custom casts and attributes.
The former include casting to the aforementioned state classes while the latter includes accessing the decompressed and decoded content.
Models register media collections for storing files by setting its name, accepted MIME (Multipurpose Internet Mail Extensions) types and the amount of files they can hold.

Finally, for most of the mentioned models I extended the special boot method with additional functionality. Inside this the CRUD functionality can be extended with additional logic.
Examples include ensuring that sites transfer to the draft state when one of their pages gets updated, ensuring that a home page (\texttt{/}) exists for all sites, and relationship and media clean up logic upon model deletion.

A feature related to models is factories which allows the developer to create instances of models with set default attributes and persist them to the database.
Another related feature is database seeding which allows us to populate the database with initial data.
Since I use the aforementioned capabilities mostly for testing I will go into more detail about them in Section \ref{section:backend-testing}.
For development purposes, however I use the user model's factory to create a super-admin user and seed roles and permissions into the database.
I will talk about the previously mentioned features more in Subsection \ref{subsection:authorization}.

The final component related to the Eloquent ORM I used and want to mention here is API resource classes. They provide a way to transform models into the JSON format that is returned to the application's frontend.
It can be thought of as a Data Transfer Object (DTO) implementation as resource classes allow fine granular control over the returned properties.
Fields can be hidden from models, relationships can be included with select fields, and any custom or calculated field can be defined.
Moreover, resource collection classes can be defined which define how to return a collection of the given model as opposed to returning a singular instance.
Furthermore, resources classes can also be defined without them being connected to a given model.
For each model and endpoint I defined a corresponding resource and resource collection class.
In order to parse request and responses from the proxy application I implemented custom deployment resources as well.
I organized all of these classes  according to the API versioning, to which refer to Subsection \ref{subsection:crud}.

\subsection{Authentication}
Moving on from the ORM features, next I will describe the implementation of the authentication capabilities of the backend.
The combination of two packages maintained by the Laravel team provide the functionality, the first being Laravel Sanctum, while the second is Laravel Fortify.

Laravel Sanctum provides API token based, SPA session based and Mobile token based authentication methods and provides CORS (Cross-Origin Resource Sharing) and CSRF (Cross-Site Request Forgery) protections for better security.
Out of these three I only used the SPA session based authentication using cookies for the frontend.
To begin with the \texttt{SANCTUM\_STATEFUL\_DOMAINS} environment variable has to be set with the frontend and proxy URLs.
Next, in the application bootstrapper the stateful API global middleware has to be applied.
Lastly the CORS configuration should be published, and the allowed paths have to be set.

In contrast, Laravel Fortify provides a frontend agnostic implementation of authentication features for the backend.
In other words it implements the routes and controllers for login, registration, password reset and confirmation, email verification and two-factor authentication if needed.
Each of these features can be enabled or disabled in its own configuration file.
Additionally fortify can provide Blade templating based views for each of these features if needed however since I will use an SPA frontend I disabled them.
I also opted-out from the two-factor authentication capabilities, the rest however are fully supported by the developed application suite.

%TODO: sanctum ,fortify, overrides, middleware
\subsection{Authorization}
\label{subsection:authorization}
%TODO: gates, policies, roles and permissions (enums) seeding, middleware
\subsection{Core CRUD}
\label{subsection:crud}
\subsection{Deployment Logic}
%TODO: Sequence diagram for deployment logic?
\subsection{Admin Panel}