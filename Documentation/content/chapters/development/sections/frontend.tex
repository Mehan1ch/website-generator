\section{Frontend}
\label{section:frontend}

\subsection{Setup and overview}
I implemented the frontend using React first and foremost.
The most important packages I used are TanStack Router for client side routing, TanStack query for robust data fetching and caching, and CraftJS for the editor capabilities.

As the first step, the React app has to be installed.
I scaffolded the application using the Vite bundling tool's CLI and chose a TypeScript based application.
Then I set TypeScript to use strict type checking to disallow \texttt{any} types, and also installed TailwindCSS and its Vite plugin as I used the ShadCN UI components.
ShadCN distributes its components and blocks in an open code manner through the npx CLI, which means that instead of installing a npm package, the source code of the block gets copied into the application.
This has the advantage that the components can be completely customized if needed, and the downside that the repository size grows considerably.

I also used predesigned UI blocks form ShadCN.IO \cite{shadcn.io_2025}.
While I was building the application all components from this site were open-sourced and free, however as of writing this documentation they introduced many new blocks that got locked behind a subscription. Previously free blocks remained as such, but require a free account now. This change doesn't affect the application as the source code got inserted into the project directly so further use and modification is possible.

Next I used Docker's init command to scaffold a Dockerfile and docker-compose.yaml for containerization, to which I only made minor changes, mostly regarding setting up environment variables.
I also configured ESLint, which is a static code analyser, to ensure better code quality.

Since unlike Laravel, React is unopinionated about the structure of the application, let me talk about how I architected the frontend's folder structure.
I was partly inspired by the Bulletproof React repository \cite{alan2207/bulletproof-react}, however I made a few changes to better fit my needs.
The high level overview of the layout can be seen on Figure \ref{fig:react-structure}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/frontend-struct.png}
  \caption{React application structure}
  \label{fig:react-structure}
\end{figure}

The \texttt{main.tsx} is the setup file for the frontend application, about which I will go into detail shortly.
The \texttt{routeTree.gen.ts} contains the routing tree that TanStack router generates.
For more information about this refer to Subsection \ref{subsection:tanstack-router}.
The \texttt{components} folder contains the UI elements added by the ShadCN library and other component blocks I created using them that are global to the application.
The \texttt{context} includes the globally defined application contexts, that I will talk about in Subsection \ref{subsection:api-context}.
Inside \texttt{hooks} live the custom React hooks that I defined.
\texttt{Lib} collects utility functions, global constants and the generated API client, which I will elaborate in Subsection \ref{subsection:api-context}.
The \texttt{providers} folder houses the context providers that the aforementioned context objects return.
\texttt{Routes} encompass not only the route hierarchy but using the router's \texttt{-} notation it also colocates any route specific components and logic.
The \texttt{testing} folder accommodates all test related files.
Refer to Subsection \ref{section:testing-frontend} for a thorough explanation.
Finally, \texttt{types} include all TypeScript types that are either generated by the API client or Zod schemas.

Zod is a library used for schema validation primarily focusing on TypeScript.
I used it in conjunction with React Hook Form, a hook based form library for React, to generate form schemas and provide client side validation.
I also validated search parameters using it in a few routes. A great feature of Zod is that TypeScript types can be inferred from form schemas for further use.

Now let me talk about setting up the application in the \texttt{main.tsx} file.
Some details will be expanded upon later but are understandable at this point as well.

First a router instance has to be constructed, to which the route tree needs to be provided. Additionally, the router context has to be configured with initial values.
This has to include everything that routes need to have access to before even rendering their component.
In my case this contained TanStack query's query client, which is constructed here, the auth context, and a default callback that returns the given routes title.
The latter will be overridden in each route and will be used for breadcrumb generation.
The auth context is undefined at this point and will be updated later.
Here I also set up a default view transition that provides a smoother animation between route switching and scroll restoration.
Moreover, I configured the loader stale time to 0 (never stale) as the query client will handle that instead of the router (both share this concept).
Finally, I changed the default preload method to 'intent', which has the effect of launching loader preloads after 50 milliseconds when a user hovers on the link of the destination route.

Next a component I called \texttt{InnerApp} has to be created.
This component's only purpose is to have access to the useAuth hook and return the router provider with the router instance and a now existing valid authentication context.
The router provider will take care of rendering child routes.

Moving on, I created an \texttt{App} component which wraps the previous \texttt{InnerApp} with the auth provider, the theme provider, and query client provider.
The query client provider has access to the same query client as the router.
Also, I included the \texttt{Toaster} component from the Sonner package created by Emil Kowalski alongside the \texttt{InnerApp}.
This package an easy-to-use and opinionated way of making toast notifications.
I primarily use it to provide feedback to the user from background tasks such as API calls.

Last but not least the \texttt{App} itself is surrounded with React's strict mode component that enables development only extra behaviours with the aim of finding common bugs.
In production, it has no effect and is turned off.
At the end of all this, the component chain gets rendered by the root React DOM object, which finishes the setup process, as the \texttt{index.html} by default includes the \texttt{main.tsx} script.

\subsection{API client and context providers}
\label{subsection:api-context}

After the setup process, I will move on to describing the features mainly in the \texttt{context}, \texttt{providers}, \texttt{hooks}, and \texttt{lib} folders.

Generating the OpenAPI scheme of the backend has the great benefit of allowing me to take advantage of the many available libraries specializing in API client code generation.
I investigated a couple of existing solutions, namely Orval, Kubb, and OpenAPI-TS.
Orval and Kubb both feature an extendible approach where you can pick what you want to use.
However, they both proved to be way more complicated than what I needed, so I opted to use OpenAPI-TS.
OpenAPI-TS provides many smaller libraries that provide client-side code generation from OpenAPI schemas.
For my use case OpenAPI-React-Query was the one I needed and ended up using.
It is a tiny, around 1kb wrapper around TanStack Query and incorporates two other libraries by the same author, OpenAPI-Fetch and OpenAPI-TypeScript.
It validates the available API routes inside the query calls, checks parameters and bodies, and can be used to generate TypeScript types for the requests and responses.

Next I generated the API client with the library in the \texttt{lib/api} folder and also customized the fetch client used by it.
Namely, I created a custom \texttt{APIError} class that handles error messages from the backend, configured the base URL from environment variables and the default headers.
Additionally, since the backend uses CORS and CSRF protection it requires requests to have a valid XRSF token.
This can be obtained by first making a request to the \texttt{/sanctum/csrf-cookie} endpoint.
This was also configured in the fetch client to be handled automatically and re-fetch when the token expires.

Moving on, I implemented the custom theme and authentication providers.
I was guided by the ShadCN documentation \cite{shadcn_2025} on how to configure light, dark, and system themes using TailwindCSS's functionality.
The provider stores the selected theme in and recovers it from the browser's local storage on subsequent visits.
Toggling the themes are possible from the account page, and the app defaults to the system theme.
Accessing the theme in other components is possible through a custom \texttt{useTheme} hook.

Afterwards I created the authentication provider for auth state management.
It provides through the \texttt{useAuth} hook methods for logging in, registering, logging out, re-fetching user context and deleting the account.
All these methods use the API client wrapping TanStack Query's mutations and query functions.
The context encompasses two React states, one a boolean for quick checks, and the other containing the logged-in user's information.
I also store the state in the browser's local storage and recovered upon mounting by an \texttt{useEffect} call so that the user remains logged in on revisits.
%TODO: use case diagrams should be used here the rest of the pictures can be UI showcasing screenshots