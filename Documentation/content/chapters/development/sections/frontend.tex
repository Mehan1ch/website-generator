\section{Frontend}
\label{section:frontend}

\subsection{Setup and overview}
\label{subsection:frontend-setup}
I implemented the frontend using React first and foremost.
The most important packages I used are TanStack Router for client side routing, TanStack query for robust data fetching and caching, and CraftJS for the editor capabilities.

As the first step, the React app has to be installed.
I scaffolded the application using the Vite bundling tool's CLI and chose a TypeScript based application.
Then I set TypeScript to use strict type checking to disallow \texttt{any} types, and also installed TailwindCSS and its Vite plugin as I used the ShadCN UI components.
ShadCN distributes its components and blocks in an open code manner through the npx CLI, which means that instead of installing a npm package, the source code of the block gets copied into the application.
This has the advantage that the components can be completely customized if needed, and the downside that the repository size grows considerably.

I also used predesigned UI blocks form ShadCN.IO \cite{shadcn.io_2025}.
While I was building the application all components from this site were open-sourced and free, however as of writing this documentation they introduced many new blocks that got locked behind a subscription. Previously free blocks remained as such, but require a free account now. This change doesn't affect the application as the source code got inserted into the project directly so further use and modification is possible.

Next I used Docker's init command to scaffold a Dockerfile and docker-compose.yaml for containerization, to which I only made minor changes, mostly regarding setting up environment variables.
I also configured ESLint, which is a static code analyser, to ensure better code quality.

Since unlike Laravel, React is unopinionated about the structure of the application, let me talk about how I architected the frontend's folder structure.
I was partly inspired by the Bulletproof React repository \cite{alan2207/bulletproof-react}, however I made a few changes to better fit my needs.
The high level overview of the layout can be seen on Figure \ref{fig:react-structure}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/frontend-struct.png}
  \caption{React application structure}
  \label{fig:react-structure}
\end{figure}

The \texttt{main.tsx} is the setup file for the frontend application, about which I will go into detail shortly.
The \texttt{routeTree.gen.ts} contains the routing tree that TanStack router generates.
For more information about this refer to Subsection \ref{subsection:tanstack-router}.
The \texttt{components} folder contains the UI elements added by the ShadCN library and other component blocks I created using them that are global to the application.
The \texttt{context} includes the globally defined application contexts, that I will talk about in Subsection \ref{subsection:api-context}.
Inside \texttt{hooks} live the custom React hooks that I defined.
\texttt{Lib} collects utility functions, global constants and the generated API client, which I will elaborate in Subsection \ref{subsection:api-context}.
The \texttt{providers} folder houses the context providers that the aforementioned context objects return.
\texttt{Routes} encompass not only the route hierarchy but using the router's \texttt{-} notation it also colocates any route specific components and logic.
The \texttt{testing} folder accommodates all test related files.
Refer to Subsection \ref{section:testing-frontend} for a thorough explanation.
Finally, \texttt{types} include all TypeScript types that are either generated by the API client or Zod schemas.

Zod is a library used for schema validation primarily focusing on TypeScript.
I used it in conjunction with React Hook Form, a hook based form library for React, to generate form schemas and provide client side validation.
I also validated search parameters using it in a few routes. A great feature of Zod is that TypeScript types can be inferred from form schemas for further use.

Now let me talk about setting up the application in the \texttt{main.tsx} file.
Some details will be expanded upon later but are understandable at this point as well.

First a router instance has to be constructed, to which the route tree needs to be provided. Additionally, the router context has to be configured with initial values.
This has to include everything that routes need to have access to before even rendering their component.
In my case this contained TanStack query's query client, which is constructed here, the auth context, and a default callback that returns the given routes title.
The latter will be overridden in each route and will be used for breadcrumb generation.
The auth context is undefined at this point and will be updated later.
Here I also set up a default view transition that provides a smoother animation between route switching and scroll restoration.
Moreover, I configured the loader stale time to 0 (never stale) as the query client will handle that instead of the router (both share this concept).
Finally, I changed the default preload method to 'intent', which has the effect of launching loader preloads after 50 milliseconds when a user hovers on the link of the destination route.

Next a component I called \texttt{InnerApp} has to be created.
This component's only purpose is to have access to the useAuth hook and return the router provider with the router instance and a now existing valid authentication context.
The router provider will take care of rendering child routes.

Moving on, I created an \texttt{App} component which wraps the previous \texttt{InnerApp} with the auth provider, the theme provider, and query client provider.
The query client provider has access to the same query client as the router.
Also, I included the \texttt{Toaster} component from the Sonner package created by Emil Kowalski alongside the \texttt{InnerApp}.
This package an easy-to-use and opinionated way of making toast notifications.
I primarily use it to provide feedback to the user from background tasks such as API calls.

Last but not least the \texttt{App} itself is surrounded with React's strict mode component that enables development only extra behaviours with the aim of finding common bugs.
In production, it has no effect and is turned off.
At the end of all this, the component chain gets rendered by the root React DOM object, which finishes the setup process, as the \texttt{index.html} by default includes the \texttt{main.tsx} script.

One last thing I want to talk about here is the root route.
It must be named as \texttt{\_\_root.tsx} and is the root of the route tree. Here the library's Outlet component has to be returned which will take care of rendering all child routes.
Additionally, I implemented application wide, loading, not found and error boundary components to provide a better UX for these scenarios.

For example Figure \ref{fig:not-found} the not found component that renders when a user navigates to a non-existent route.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/not-found.png}
  \caption{Not found component for missing routes}
  \label{fig:not-found}
\end{figure}

\subsection{API client and context providers}
\label{subsection:api-context}

After the setup process, I will move on to describing the features mainly in the \texttt{context}, \texttt{providers}, \texttt{hooks}, and \texttt{lib} folders.

Generating the OpenAPI schema of the backend has the great benefit of allowing me to take advantage of the many available libraries specializing in API client code generation.
I investigated a couple of existing solutions, namely Orval, Kubb, and OpenAPI-TS.
Orval and Kubb both feature an extendible approach where you can pick what you want to use.
However, they both proved to be way more complicated than what I needed, so I opted to use OpenAPI-TS.
OpenAPI-TS provides many smaller libraries that provide client-side code generation from OpenAPI schemas.
For my use case OpenAPI-React-Query was the one I needed and ended up using.
It is a tiny, around 1kb wrapper around TanStack Query and incorporates two other libraries by the same author, OpenAPI-Fetch and OpenAPI-TypeScript.
It validates the available API routes inside the query calls, checks parameters and bodies, and can be used to generate TypeScript types for the requests and responses.

Next I generated the API client with the library in the \texttt{lib/api} folder and also customized the fetch client used by it.
Namely, I created a custom \texttt{APIError} class that handles error messages from the backend, configured the base URL from environment variables and the default headers.
Additionally, since the backend uses CORS and CSRF protection it requires requests to have a valid XRSF token.
This can be obtained by first making a request to the \texttt{/sanctum/csrf-cookie} endpoint.
This was also configured in the fetch client to be handled automatically and re-fetch when the token expires.

Moving on, I implemented the custom theme and authentication providers.
I was guided by the ShadCN documentation \cite{shadcn_2025} on how to configure light, dark, and system themes using TailwindCSS's functionality.
The provider stores the selected theme in and recovers it from the browser's local storage on subsequent visits.
Toggling the themes are possible from the account page, and the app defaults to the system theme.
Accessing the theme in other components is possible through a custom \texttt{useTheme} hook.

Afterwards I created the authentication provider for auth state management.
It provides through the \texttt{useAuth} hook methods for logging in, registering, logging out, re-fetching user context and deleting the account.
All these methods use the API client wrapping TanStack Query's mutations and query functions.
The context encompasses two React states, one a boolean for quick checks, and the other containing the logged-in user's information.
I also store the state in the browser's local storage and recovered upon mounting by an \texttt{useEffect} call so that the user remains logged in on revisits.

\subsection{Authentication, dashboard and account routes}

In this block I will mainly be presenting the authentication and account related pages that I created on the frontend.
To begin with, a use case diagram on Figure \ref{fig:auth-use-case} shows in detail the authentication capabilities.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/auth-use-case.png}
  \caption{Authentication use cases}
  \label{fig:auth-use-case}
\end{figure}

Guests or unauthenticated users can log in, register and ask for a forgot password link which redirects them to a form allowing them to reset their password.
Authenticated users can verify their email's which they automatically get after registration or can request a new on the account page, which I will talk about later.
Obviously if the user clicks on the verification link in their email while being unauthenticated they will first be redirected to the login page.

When a user first visits the frontend a simple index page greets them with directions to login, or register, or go to the dashboard if already logged in.
The index page as shown for an unauthenticated user can be seen on Figure \ref{fig:index-page}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/index-page.png}
  \caption{Index page for an unauthenticated user}
  \label{fig:index-page}
\end{figure}

From the landing page, the user can directly log in and or register.
As stated previously I used React Hook Form with Zod for creating all my forms.
This ensures that there is proper client side validation, and can be used to display meaningful error messages to the user.
All forms also employ a loading state to prevent multiple submissions while a previous request is running.
I also display success and error responses using the aforementioned toast notifications in the bottom right corner of the screen.
The registration page with an example for validation errors can be seen on Figure \ref{fig:register}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/register.png}
  \caption{Register page with validation errors}
  \label{fig:register}
\end{figure}

The rest of the forms look almost identical to the registration one, so I won't show each one-by-one unnecessarily.
One thing worth mentioning is that both the registration and forgot password links send out email.
Such an example email after registration captured by Mailpit can be seen on Figure \ref{fig:email}. On the sidebar the incoming password reset links can be seen as well.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/email.png}
  \caption{Registration email seen in Mailpit}
  \label{fig:email}
\end{figure}

After logging in, the user can access the main application routes grouped by the \texttt{\_app} folder.
They are all surrounded with a layout component that has two main responsibilities.
First check if the user has successfully logged in, if not redirect them to the login route.
Secondly this is where the title callback I mentioned in Subsection \ref{subsection:frontend-setup} is used.
The layout component collects the result of all title callbacks from the router state, which include the title names for all rendered child routes.
Afterwards it dynamically builds the breadcrumb trail displayed to the user.

The first such route is the dashboard, which displays a few statics and quick actions.
Figure \ref{fig:dashboard} showcases it in detail.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/dashboard.png}
  \caption{The dashboard page}
  \label{fig:dashboard}
\end{figure}

Next let me provide and overview of account settings, which can be accessed via a pop-over by clicking on the user section of the sidebar.
Another use case diagram showcasing the account related options can be seen on Figure \ref{fig:account-use-case}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{./figures/account-use-case.png}
  \caption{Account settings use cases}
  \label{fig:account-use-case}
\end{figure}

The user is able to switch the application between light, dark, and system themes.
They can also update their profile information which includes changing their display name and email.
Changing the email automatically sends a verification email for the new address.
They can upload an avatar via a drag and drop field or the system file chooser, which can be previewed before saving.
A tab which show the verification status is available, and if unverified a new link can be sent from here.
Password's can be changes using a form, that shows the new password's strength using simple metrics like length and contained special characters.
After changing it the user will be logged out automagically and prompted to log in again.
Lastly the account can be deleted if the user wishes so.
This will first show a confirmation dialog to avoid accidental deletion.

Two pictures comparing light and dark modes can be seen on Figure \ref{fig:theming}.
The light mode picture on Subfigure \ref{subfig:light-avatar} showcases the avatar upload tab, while the dark mode picture on Subfigure \ref{subfig:dark-password} presents the password change form.
The light mode picture also displays, how to get to the account settings page.

\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.49\textwidth}
    \centering
    \includegraphics[width=\textwidth]{./figures/light-avatar.png}
    \caption{Light mode avatar upload}
    \label{subfig:light-avatar}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.49\textwidth}
    \centering
    \includegraphics[width=\textwidth]{./figures/dark-password.png}
    \caption{Dark mode password change}
    \label{subfig:dark-password}
  \end{subfigure}
  \caption{Dark and light modes}
  \label{fig:theming}
\end{figure}

\subsection{Schemas, sites, and pages}

\subsection{Editor}